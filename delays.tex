\section{Introducing real-time in SystemJ}
\label{sec:intr-real-time}

We introduce a single \textit{derived} (built from kernel constructs)
statement called \mbox{\texttt{delay (M..N)}} in the SystemJ language
for real-time control. The resolution of the delay statement is of
secondary concern and is dependent upon the execution platform. 


\subsection{Semantics of the delay statement}
\label{sec:semant-delay-stat}

Given a SystemJ program: \texttt{delay (M..N); p}, where $M \in
\mathbb{Q}^{>0}$ and $N \in \mathbb{Q}^{>0}$, statement $p$ is executed
after real-time delay of $\tau$ units, such that, $M \leq \tau \leq N$.

We also introduce two variants of the derived statement \texttt{delay}.
\begin{enumerate*}
\item Given a SystemJ program \texttt{delay (M); p}, where $M \in
  \mathbb{Q}^{>0}$, statement $p$ is executed after real-time delay of
  $\tau$ units, such that, $M \leq \tau < \infty$. It is important to
  note that the lower bound of the delay construct $M$ is \textit{not}
  an exact delay, but rather the control is allowed to proceed to the
  next statement anytime after the delay of time $M$.
\item Given a SystemJ program \texttt{delay (M..M); p}, where $M \in
  \mathbb{Q}^{>0}$, statement $p$ is executed after real-time delay of
  $\tau$ units, such that, $M \leq \tau \leq M$. In this variant, the
  delay is exact.
\end{enumerate*}

The aforementioned variants are special cases of the general case
\texttt{delay (M..N)}.

\subsection{Rewriting the \texttt{delay} statement}
\label{sec:rewr-delay-stat}

The introduced \texttt{delay} construct is not a kernel construct, but a
\textit{derived} construct built from the kernel constructs
(Table~\ref{tab:1}) in SystemJ. Figure~\ref{fig:3} gives the rewrite of
the \texttt{delay} construct to kernel statements.

\begin{figure}[tb]
    \begin{minipage}{\textwidth}
      \begin{scriptsize}
\begin{verbatim}
trap(T){
 int x = 0;
 while(true){
  x = x + 1;
  pause;
  if(x == d) exit (T); //wait for "d" ticks
 } // d is the number of logical ticks calculated
} // by Algorithm 1
\end{verbatim}
      \end{scriptsize}
    \end{minipage}
    \caption{The rewrite of \texttt{delay} construct}
    \label{fig:3}
\end{figure}

The fundamental observation is that real-time is converted into logical
time via the \texttt{pause} construct. The rewrite basically maps the
physical notion of time back to the elegant logical notion of time. The
rewrite \textit{delays} a certain number of logical ticks, before
proceeding to the next statement. The number of logical ticks \texttt{d}
to \textit{delay} (Figure~\ref{fig:3}) is determined by the compiler
statically at compile time. The value of \texttt{d} is intricately tied
with the WCRT and BCRT of the program and hence the execution platform.

\subsection{Finding the logical delay \texttt{d}}
\label{sec:find-logic-delay}

\begin{algorithm}[t!]
  \begin{minipage}{1.0\linewidth}
    \SetAlgoLined
    \KwData{WCRT, BCRT, $M \in \mathbb{Q}^{>0}$, $N \in \mathbb{Q}^{>0}$}
    \KwResult{d}
    let $l_1 \leftarrow \lceil \frac{M}{WCRT} \rceil$\;
    let $l_2 \leftarrow \lceil \frac{M}{BCRT} \rceil$\;
    let $u_1 \leftarrow \lfloor \frac{N}{WCRT} \rfloor$\;
    let $u_2 \leftarrow \lfloor \frac{N}{BCRT} \rfloor$\;
    let $F:(l_1,u_1) \rightarrow S_1$\;
    let $F:(l_2,u_2) \rightarrow S_2$\;
    let $D \leftarrow S_1 \cap S_2$\;
    \Return (some $d \in D$)\;
    \caption{Finding the value of \texttt{d}}
    \label{alg:1}
  \end{minipage}
\end{algorithm}

The computation of \texttt{d} is shown in Algorithm~\ref{alg:1}. This
algorithm is carried out for each CD (in SystemJ) or a synchronous
program individually. \textit{The fundamental observation is -- the
  reaction time for each logical tick is elastic -- varying only between
  the BCRT and the WCRT, thus any number of logical ticks \texttt{d}
  that map to the required real-time \texttt{delay} should be chosen in
  such a way that they are invariant to this elasticity.}

Our algorithm takes as input: WCRT, BCRT, and the lower and upper bounds
$M$ and $N$, respectively of the \texttt{delay} construct. We first
divide $M$ and $N$ with the BCRT and WCRT, respectively. This division
gives us the number of individual logical ticks required to delay the CD
(or synchronous program) by the real-time specification. We always
$ceil$ when dividing $M$ and $floor$ when dividing $N$ to make sure that
the resultant values are integers (in domain $\mathbb{N}^{>0}$) and
these functions guarantee that the resultant logical ticks result in
real-time delays between the required range $[M,N]$. Next, a function
$F$ maps these calculated values to a set of equidistant integer points
(values) separated by a unit value -- these points represent all the
logical ticks running at the WCRT and the BCRT, respectively that
satisfy the real-time delay requirements. The intersection of these two
sets gives all the logical ticks that satisfy the real-time requirements
invariant of the logical time and its elasticity.

Let us revisit our motivating example to illustrate the algorithm. From
Figure~\ref{fig:1} we know that $M$ is 50.3 ms and $N$ is 200.3 ms,
respectively. Let the WCRT and BCRT be: 0.112 ms and 0.0334 ms,
respectively. Thus, the algorithm proceeds as follows:

\begin{enumerate*}
\item $l_1 \leftarrow \lceil 50.3/0.112 \rceil$ and $u_1 \leftarrow
  \lfloor 200.3/0.112 \rfloor$. $l_1 = 450$ and $u_1 = 1788$. We first
  calculate the logical ticks that are always running at the WCRT and
  satisfy the required real-time delay.
\item $l_2 \leftarrow \lceil 50.3/0.0334 \rceil$ and $u_2 \leftarrow
  \lfloor 200.3/0.0334 \rfloor$. $l_1 = 1506$ and $u_1 = 5997$. We do
  the same for the BCRT case.
\item $S_1 = [450,1788]$ and $S_2 =[1506,5997]$. We then map the
  resultant bounds to linear points. Sets $S_1$ and $S_2$ represent
  logical ticks that running at the WCRT and BCRT, respectively always
  satisfy the required real-time constraints.
\item $D = S_1 \cap S_2$, $D = [1506,1788]$. Finally, the intersection
  of the two sets gives the set $D$ from which we can choose any value
  for \texttt{d}.
\end{enumerate*}

The resultant value for \texttt{d} gives the number of logical ticks,
which can run at any physical clock-speed, bounded by the BCRT and the
WCRT of the program and still result in the desired real-time delay. We
think this is an elegant solution, because the technique provides
real-time guarantees while preserving the essence (elastic logical tick)
of synchronous and GALS programming prescribed by SystemJ and Esterel
style languages. Moreover, this technique considers non
maximal-parallelism, i.e., the delay in logical ticks is calculated
after scheduling of CDs or synchronous programs has been performed. To
our knowledge we are the first to do so.

\subsection{Extending the technique to variants of \texttt{delay}}
\label{sec:extend-tehcn-vari}

\paragraph{The \texttt{delay(M)} construct}
\label{sec:extend-techn-vari}

The \texttt{delay(M)} variant is easily accommodated in the
technique. All one needs to do is find the set $S_1$ and choose a value
from this set.

\paragraph{The \texttt{delay(M..M)} construct}
\label{sec:extend-techn-vari}

The \texttt{delay(M..M)} variant is a little more interesting. Like
before we find sets $S_1$ and $S_2$, and find the intersection of the
two sets to get the value of \texttt{d}. It is possible (and often
likely, as suggested by our experiments in
Section~\ref{sec:experimental-results}) that the resultant set $D$ is
empty (also possible in the case of \texttt{delay(M..N)}, but never
possible in case of \texttt{delay(M)}). Note that $S_1$ and $S_2$ can
never be empty sets and will always contain at minimum a single
element. In such a case, we automatically \textit{relax} the upper bound
of the \texttt{delay} statement.

\paragraph{Relaxation of the upper real-time bound}
\label{sec:over-appr-relax}

The relaxation technique is shown in Algorithm~\ref{alg:2}.
  
\begin{algorithm}[t!]
  \begin{minipage}{1.0\linewidth}
    \SetAlgoLined
    \KwData{$S_2$, $D$, WCRT}
    \KwResult{d}
    \If {$D = \emptyset$} {
      let $j_{0}$ be the first element of set $S_2$\;
      \ShowLn let $N \leftarrow WCRT \times j_0$\;
      let $d \leftarrow j_0$\;
    }
    \Return d\;
    \caption{Calculating the minimum relaxation of the upper real-time
      bound}
    \label{alg:2}
  \end{minipage}
\end{algorithm}


This algorithm results in the \underline{smallest} relaxation required
for the real-time delay to be satisfied. The algorithm takes as input
the WCRT and set $S_2$, recall that set $S_2$ represents the logical
ticks required to satisfy the real-time requirement at the BCRT. We take
the very first value from set $S_2$ and multiply it with the WCRT to get
the relaxation $N$. The first element of set $S_2$ is returned as the
logical tick delay \texttt{d}. The fundamental observation is that we
have to delay for a minimum of $M$ units of real-time, hence,
under-approximation is out of question. We can still over-approximate,
but to reduce the resultant error, we should over-approximate by least
possible value, which is the lower bound of set $S_2$. Thus, the lower
bound is considered to be the only element shared between the two sets
$S_1$ and $S_2$ and accordingly, the upper real-time bound is relaxed by
the multiplication of WCRT and the first element of set $S_2$.

For example, assume $BCRT=5$ and $WCRT=100$, with a required delay of
$(200..200)$. Algorithm~\ref{alg:1}, results in $D$ being an empty set,
since $S_1=[2]$ and $S_2=[40]$, respectively. In such a case, the
resultant relaxation is: $40 \times 100$ using Algorithm~\ref{alg:2},
which results in a time of $4000$ units. Such large over-approximations
can be avoided by breaking the critical paths (worst case ticks) in the
program (by inserting pause constructs), just like in hardware design,
which is very \textit{unsurprising} considering Esterel has its origins
in hardware.

\subsection{The compiler flow}
\label{sec:systemj-tool-chain}

\begin{figure}[t!]
  \centering
  \includegraphics[scale=0.5]{./tool}
  \caption{The tool-chain flow of SystemJ compiler with delays}
  \label{fig:4}
\end{figure}

The interaction of the low-level execution platform and the described
high-level technique of introducing real-time delays in the SystemJ
language is shown in Figure~\ref{fig:4}. We use static-analysis
techniques to find out the WCRT/BCRT of the programs automatically after
rewrites and standard compiler optimizations. We require timing
analyzable platforms, in our case \textit{Java Optimized Processor}
(JOP)~\cite{jop:jnl:jsa2007}. Moreover, since algorithms~\ref{alg:1}
and~\ref{alg:2} are performed after scheduling for different constraints
such as faster execution time, or reduced power consumption, we,
inherently satisfy the criteria of exploiting non-maximal
parallelism. The low-level analysis guarantees a precise WCRT/BCRT for
the logical tick, which is then used for calculating $d$ in
Figure~\ref{fig:3}.

\subsection{Programming using the delay construct}
\label{sec:progr-using-delay}

In this section we provide a number of examples to show the different
types of real-time programming paradigms that can be incorporated into
the GALS (and its sub-set synchronous) programming model.

\subsubsection{Non-deterministic time}
\label{sec:non-determ-time}

Many real-world systems require non-deterministic timing
constructs. Where the exact real-time delay is not known or should not
be known apriori. One such system is our motivating example -- the human
response time system.

\subsubsection{Timeout}
\label{sec:timeout}

There are many instances when one would like to wait on an input from
environment for only a specified amount of time. This can be programmed
as:
% \begin{scriptsize}
\begin{verbatim}
// timeout after 1ms.
trap(T){{await(A);}||
        {delay(1..1 ms);exit(T);}}
\end{verbatim}
% \end{scriptsize}

\subsubsection{Periodic reactions}
\label{sec:periodic-reactions}

A reaction, or a whole CD, can be programmed to run periodically like
so:

% \begin{scriptsize}
\begin{verbatim}
while(true) { delay ((1..1)ms); emit S; 
 //do something }
\end{verbatim}
% \end{scriptsize}
A periodic reaction (or CD) requires special consideration. Since the
delay statement is converted into \texttt{pause} constructs. One should
not introduce extra \texttt{pause} constructs when building periodic
reactions (or CDs). This is essential since introducing additional
pauses would introduce more logical ticks.

\subsubsection{Interaction of preemption and delays}
\label{sec:inter-preempt-delays}

Preemption plays an important role in reactive languages. One needs to
carefully consider the interplay of \texttt{delay} semantics with the
preemption semantics of reactive languages. Previous attempts at
incorporating delays (using external timers) have only been partially
successful, because of the complex interplay between real-time and
preemption. Consider the simple example below, which models real-time
using external timers as in~\cite{rsh94}.

% \begin{scriptsize}
\begin{verbatim}
suspend(S) {emit START_TIMER(10); 
            await (TIMER);emit O1;}
\end{verbatim}
% \end{scriptsize}

As identified in~\cite{Bourke2009a} \texttt{suspend} does not play well
with the external timer. The above program sends a signal to an external
timer and waits for 10 ms to pass by. Consider what happens when signals
\texttt{S} and \texttt{TIMER} occur in the same logical tick, the
\texttt{await} statement is never executed (due to suspend) and hence,
we enter a deadlock. Such problems are completely avoided in our
technique, because we convert the real-time delays into logical delays
(\texttt{pause} constructs), which interact well with preemption.

\subsubsection{Interaction of channel communication and delays}
\label{sec:inter-chann-comm}

Channels, used for communication between reactions in asynchronously
running CDs, are an addition in the SystemJ language. Like interaction
of preemption and delays, conversion of real-time delays to logical
ticks also interacts well with channel rendezvous, because the semantics
of interaction are well defined~\cite{amal10}. More importantly, we need
to consider the interplay of channel communication and WCRT/BCRT
analysis. Since, channel communication does not stop logical time
(see~\cite{amal10}) WCRT/BCRT are unaffected by channel
communication. % The response time to input signals \textit{is} though!
% But, we are unconcerned with the response time, analysis in this paper
% and it remains a future research avenue.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 

