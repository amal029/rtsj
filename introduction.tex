\section{Introduction and motivation}
\label{sec:intr-motiv}

Reactive languages~\cite{gber931,amal10} are a class of programming
languages used for designing and implementing reactive systems, which
continuously respond to input from their environment. These languages
have been successfully used in programming a plethora of systems such as
fly-by-wire in Airbus~\cite{eairbus}, security surveillance
systems~\cite{amal121}, etc.  Usually these systems also need to meet
real-time constraints enforced by the environment. Yet, these languages
do not support describing real-time statements as first class language
constructs.  For example, one cannot describe a simple real-time delay
(postponement) of an operation for 0.2 ms. These languages are based on
formal semantics, essential for the formal reasoning about and
verification of correctness of functional properties of the developed
programs, but leave nonfunctional properties such as timing behavior as
an implementation detail~\cite{boldt07}. Arguably, rightly so, because
physical time cannot be incorporated without information about the
underlying execution platform.  But, one can still reason in terms of
logical time. These languages support discrete logical clock rather than
a discrete physical (real-time) clock. The real-time period of the
discrete logical clock (also referred to as a logical tick) is not fixed
and it is determined by the responsiveness of the program to the input
signals. Unlike a discrete physical clock, which has fixed real-time
period, the period of the logical clock is elastic. Although the timing
model with logical clock has worked well for reactive synchronous/GALS
languages in designing discrete systems, there is a need to introduce
real-time since, often, implementation models are in the continuous or
discrete real-time domain~\cite{DBLP:journals/pieee/SifakisTY03}.
Moreover, adding timing capabilities as first class language constructs
create additional opportunity for formally verifying functional and
non-functional requirements before system deployment.

\input{motivation}

The major motivations for introducing delay mechanism and at the same
time contributions of the paper are: (1) delays allow real-time based
synchronization between concurrent behaviors, (2) delays model relays on
the use of relative instead of absolute time, i.e., a delay in selected
time units is counted from the currently executing SystemJ statement and
(3) delays allow mixing behaviors with real-time features and others
with only logical time and (4) real-time delay does not affect the model
of logical time in SystemJ program as long as the amount of delay is
within boundaries that can be determined statically by program
analysis. All these as well as semantics of the delay construct are
discussed and illustrated in the remaining part of the paper. Our
contributions can be further refined as follows:
\begin{enumerate*}
\item Real-time is modeled in the $\mathbb{Q}^{>0}$ domain of numbers,
  i.e., non-negative rational numbers.
\item We consider the property of \textit{non
    maximal-parallelism}. \textit{Non-maximal parallelism:} There are
  not always sufficient resources for processes to execute, so
  effectively processes are allocated and scheduled with different
  optimization criteria -- reducing computation time, reducing power
  consumption, etc. This allocation and scheduling is an integral part
  of any language compilation and needs to be considered when
  introducing real-time delays.
% \item Our solution does not change the functional or timing semantics of
%   GALS and its subset synchronous programs, in fact, our solution does
%   not require one to change the mid-end, the back-end or the related
%   optimization phases of the compiler at all.
\item We are the first, to our knowledge, to allow specification of both
  deterministic and non-deterministic real-time in GALS and synchronous
  languages. \textit{Deterministic delay:} is the ability to specify a
  single \textit{real-time} delay. \textit{Non-deterministic delay:} is
  the ability to specify a range, of real-time values for a delay
  statement, e.g., delay statement in Figure~\ref{fig:1}.
\end{enumerate*}

The rest of the paper is arranged as follows:
Section~\ref{sec:background} gives the background on SystemJ and related
techniques required for the rest of the
paper. Section~\ref{sec:intr-real-time} introduces real-time delays in
the GALS paradigm and describes their compilation into logical
time. Section~\ref{sec:experimental-results} gives the experimental
results for a set of real-time
applications. Section~\ref{sec:related-work} positions this work in
relation to other approaches to introducing real-time. Finally, we
conclude in Section~\ref{sec:concl-future-work}.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
